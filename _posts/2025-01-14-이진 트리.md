---
title: 이진 트리
date: YYYY-MM-DD HH:MM:SS +09:00
categories: [Study, DataStructure]
tags:
  [
    이진 트리,
    BST,
  ]
# 이진 트리(Binary Tree)

## 목차

1.  이진 트리의 정의
2.  이진 트리의 성질
3.  이진 트리의 종류
4.  이진 트리의 탐색
    -   DFS
        -   전위 순회(Preorder Traversal)
        -   중위 순회(Inorder Traversal)
        -   후위 순회(Postorder Traversal)
    -   BFS
        -   Level Order Traversal
5.  이진 탐색 트리(Binary Search Tree)
6.  힙
    -   최대 힙
    -   최소 힙


## 이진 트리의 정의

-   각 노드가 최대 두개의 자식을 갖는 트리
-   재귀적 정의
    -   공백 트리도 이진 트리이다.
    -   T의 자식 트리가 모두 이진 트리이면 T도 이진 트리이다.


## 이진 트리의 성질

-   레벨 i에서의 최대 노드 수: 2^(i-1) (루트는 레벨 1)
-   깊이가 k일 때 최대 노드 수: 2^k-1


## 이진 트리의 종류

-   완전 이진 트리(Complete Binary Tree)
    -   마지막 레벨을 제외하고 모든 레벨이 노드로 채워져야 함
    -   마지막 레벨의 노드 수는 자유로움
-   전 이진 트리(Full Binary Tree)
    -   모든 노드가 0개 또는 2개의 자식 노드를 가짐
    -   단말 노드 수 = 내부 노드 + 1
-   포화 이진 트리(Perfect Binary Tree)
    -   깊이가 k이고 노드 수가 2^k-1개여야 함
    -   완전 이진 트리이면서 전 이진 트리임


## 이진 트리의 탐색

### DFS

-   전위 순회(Preorder Traversal)
    
    ```
    void Preorder(TreeNode *node) { 
      if (node != nullptr) { 
          cout << node->data << " "; 
          preorder(node->leftChild); 
          preorder(node->rightChild); 
      } 
    }
    ```
    
-   중위 순회(Inorder Traversal)
    
    ```
    void Inoder(TreeNode *node) { 
      if (node != nullptr) { 
          Inorder(node->leftChild); 
          cout << node->data << " "; 
          Inorder(node->rightChild); 
      } 
    }
    ```
    
-   후위 순회(Postorder Traversal)
    
    ```
    void Postoder(TreeNode *node) { 
      if (node != nullptr) { 
          Postorder(node->leftChild); 
          Postorder(node->rightChild); 
          cout << node->data << " "; 
      } 
    }
    ```

### BFS

-   Level Order Traversal이진 탐색 트리(Binary Search Tree)
```
void LevelOrder(TreeNode *root) { 
   	if (root == nullptr) return; 
   	queue<TreeNode*> q; 
   	q.push(root); 
   	while (!q.empty()) { 
       	TreeNode* node = q.front(); q.pop(); 
       	cout << node->data << " "; 
       	if (node->leftChild != nullptr) q.push(node->leftChild); 
       	if (node->rightChilde != nullptr) q.push(node->rightChild); 
   	}
}
```

-   왼쪽 자식은 부모보다 작거나 같음
-   오른쪽 자식은 부모보다 큼


## 힙
